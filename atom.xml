<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chobitly</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chobitly.github.io/"/>
  <updated>2020-07-17T08:53:52.523Z</updated>
  <id>https://chobitly.github.io/</id>
  
  <author>
    <name>Chobitly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 中请尽可能在主线程中更新 ListView 的数据源</title>
    <link href="https://chobitly.github.io/2018/03/29/Android-ListView-Update-Data-In-Main-Thread/"/>
    <id>https://chobitly.github.io/2018/03/29/Android-ListView-Update-Data-In-Main-Thread/</id>
    <published>2018-03-29T08:16:16.000Z</published>
    <updated>2020-07-17T08:53:52.523Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="程序媛" scheme="https://chobitly.github.io/categories/%E7%A8%8B%E5%BA%8F%E5%AA%9B/"/>
    
    
      <category term="Android" scheme="https://chobitly.github.io/tags/Android/"/>
    
      <category term="ListView" scheme="https://chobitly.github.io/tags/ListView/"/>
    
      <category term="线程安全" scheme="https://chobitly.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用 Android Meta Data 定制多版本不同行为的APK</title>
    <link href="https://chobitly.github.io/2016/02/05/Android-Meta-Data-With-Multi-Apk/"/>
    <id>https://chobitly.github.io/2016/02/05/Android-Meta-Data-With-Multi-Apk/</id>
    <published>2016-02-05T04:12:12.000Z</published>
    <updated>2020-07-17T08:53:52.523Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考文档如下：</p><p>[1]. <a href="http://blog.csdn.net/janice0529/article/details/41583587" target="_blank" rel="noopener">Android学习之 Manifest 中 meta-data 扩展元素数据的配置与获取</a></p><p>在前作<a href="/2016/02/05/Android-Gradle-Build/">利用 Android Studio 和 Gradle 打包多版本APK</a>所述优化完成后，我们的项目已经可以实现定制多版本不同行为的APK了，但是当时的实现方式还比较low，是通过一个工具类判断当前的Build Variant来决定各种特性的开启和值的，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BuildType为debug的版本可以重设置服务器地址。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canChangeServerUrl</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (BuildConfig.BUILD_TYPE) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"debug"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思考了半天，想到了利用 Manifest 中 meta-data 扩展元素和 build.gradle 定制占位符来实现这个定制。</p><a id="more"></a><p>仍旧以前例中<strong>是否可以重设置服务器地址</strong>为例来说明：</p><h3 id="在AndroidManifest-xml文件中为-application-标签添加如下-meta-data-："><a href="#在AndroidManifest-xml文件中为-application-标签添加如下-meta-data-：" class="headerlink" title="在AndroidManifest.xml文件中为 application 标签添加如下 meta-data ："></a>在AndroidManifest.xml文件中为 application 标签添加如下 meta-data ：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 是否可修改服务器地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"can_change_server_url"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:value</span>=<span class="string">"$&#123;can_change_server_url&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在-build-gradle-文件中定制各-BuildType-的占位符实际值，例如："><a href="#在-build-gradle-文件中定制各-BuildType-的占位符实际值，例如：" class="headerlink" title="在 build.gradle 文件中定制各 BuildType 的占位符实际值，例如："></a>在 build.gradle 文件中定制各 BuildType 的占位符实际值，例如：</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debug &#123;</span><br><span class="line">    versionNameSuffix <span class="string">'.debug'</span></span><br><span class="line">    manifestPlaceholders = [shopkeeper_app_suffix: <span class="string">"Debug"</span>,</span><br><span class="line">                            can_change_server_url: <span class="keyword">true</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在代码中获取此-meta-data-的值使用如下代码：（实际项目中会将此作为工具类封装后供业务代码调用）"><a href="#在代码中获取此-meta-data-的值使用如下代码：（实际项目中会将此作为工具类封装后供业务代码调用）" class="headerlink" title="在代码中获取此 meta-data 的值使用如下代码：（实际项目中会将此作为工具类封装后供业务代码调用）"></a>在代码中获取此 meta-data 的值使用如下代码：（实际项目中会将此作为工具类封装后供业务代码调用）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> value = context.getPackageManager()</span><br><span class="line">                    .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA)</span><br><span class="line">.metaData.getBoolean(metadataName, defaultValue);</span><br><span class="line">    <span class="comment">// 除了获取boolean类型的值之外还可以获取字符串类型、整型等其他类型的值</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要参考文档如下：&lt;/p&gt;
&lt;p&gt;[1]. &lt;a href=&quot;http://blog.csdn.net/janice0529/article/details/41583587&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android学习之 Manifest 中 meta-data 扩展元素数据的配置与获取&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在前作&lt;a href=&quot;/2016/02/05/Android-Gradle-Build/&quot;&gt;利用 Android Studio 和 Gradle 打包多版本APK&lt;/a&gt;所述优化完成后，我们的项目已经可以实现定制多版本不同行为的APK了，但是当时的实现方式还比较low，是通过一个工具类判断当前的Build Variant来决定各种特性的开启和值的，例如：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThemeHelper&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * BuildType为debug的版本可以重设置服务器地址。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;canChangeServerUrl&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (BuildConfig.BUILD_TYPE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;debug&quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;思考了半天，想到了利用 Manifest 中 meta-data 扩展元素和 build.gradle 定制占位符来实现这个定制。&lt;/p&gt;
    
    </summary>
    
      <category term="程序媛" scheme="https://chobitly.github.io/categories/%E7%A8%8B%E5%BA%8F%E5%AA%9B/"/>
    
    
      <category term="Android Studio" scheme="https://chobitly.github.io/tags/Android-Studio/"/>
    
      <category term="Meta Data" scheme="https://chobitly.github.io/tags/Meta-Data/"/>
    
      <category term="打包Apk" scheme="https://chobitly.github.io/tags/%E6%89%93%E5%8C%85Apk/"/>
    
  </entry>
  
  <entry>
    <title>利用 Android Studio 和 Gradle 打包多版本APK</title>
    <link href="https://chobitly.github.io/2016/02/05/Android-Gradle-Build/"/>
    <id>https://chobitly.github.io/2016/02/05/Android-Gradle-Build/</id>
    <published>2016-02-05T04:12:12.000Z</published>
    <updated>2020-07-17T08:53:52.523Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考文档有：</p><p>[1]. <a href="http://spencer-dev.com/blog/2015/android-xiang-mu-li-yong-android-studio-he-gradle-da-bao-duo-ban-ben-apk.html/" target="_blank" rel="noopener">Android 项目利用 Android Studio 和 Gradle 打包多版本APK</a></p><p>[2]. <a href="http://blog.robustastudio.com/mobile-development/android/building-multiple-editions-of-android-app-gradle/" target="_blank" rel="noopener">Building Multiple Editions of an Android App with Gradle</a></p><p>[3]. <a href="https://www.gitbook.com/book/avatarqing/gradlepluginuserguidechineseverision/details" target="_blank" rel="noopener">Gradle Plugin User Guide 中文版</a></p><p>[4]. <a href="https://sites.google.com/a/android.com/tools/tech-docs/new-build-system/user-guide/manifest-merger" target="_blank" rel="noopener">Manifest Merger</a></p><p>[5]. <a href="https://stackoverflow.com/questions/17976050/get-product-flavor-or-build-variant-in-an-android-app" target="_blank" rel="noopener">Get product flavor or build variant in an android app</a></p><p>[6]. <a href="https://stackoverflow.com/questions/18328730/how-to-create-a-release-signed-apk-file-using-gradle" target="_blank" rel="noopener">How to create a release signed apk file using Gradle?</a></p><p>我主要是从公司项目需求出发，依照参考文档[1]的思路学习配置Gradle来实现多版本、多ApplicationID的Apk打包，在学习过程中通过参考其他文档实现了与项目原本就采用的AndroidAnnotations框架和Robolectric测试框架的兼容，最后完成品可见此链接 <a href="https://ipensee.3322.org:8388/developers/LikeShopkeeper/blob/95ce2c2744d8dfb3442aaae80f62213264ad4286/shopkeeper/build.gradle" target="_blank" rel="noopener">build.gradle</a> （后面具体介绍时会有针对性地放出相关代码），实现了用gradle命令自动打包apk时具备以下效果：</p><ol><li>可以根据渠道不同在版本名中增加相应后缀， 可以根据特殊客户要求打包不同 ApplicationID 的 apk 包，并可分别使用不同的资源文件（如不同的应用图标等）——主要使用 productFlavors 特性；</li><li>可以为开发人员、测试人员、IT人员和正式用户打包不同的 apk 包，以便在程序行为上针对不同使用需求做少量定制（如是否可以更改远程服务器地址等）——主要使用 buildType 特性；</li><li>打包不同 ApplicationID 的 apk 包时可以与 AndroidAnnotations 框架兼容不出错—— apt arguments 中设定 resourcePackageName 参数；</li><li>测试不同 ApplicationID 的 apk 包时可以与 Robolectric 测试框架兼容不出异常——设置 TestCase 的 @Config 中各参数；</li><li>打包时可根据需求自动签名，且签名文件不需要放在项目文件夹下，可以实现不同开发设备配置不同的签名文件路径。</li></ol><p>下面将针对上述各条效果分别说明实现方法，在阅读以下内容时请确保您已至少阅读上述参考文档[1]，并建议最好阅读完上述参考文档[2]、[3]。</p><a id="more"></a><h2 id="productFlavors（不同定制的产品）"><a href="#productFlavors（不同定制的产品）" class="headerlink" title="productFlavors（不同定制的产品）"></a>productFlavors（不同定制的产品）</h2><p>完成的 build.gradle 文件中 productFlavors 部分节选如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">    flavor_default &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    flavor_lakala &#123;</span><br><span class="line">        versionName <span class="string">"$defaultConfig.versionName"</span> + <span class="string">".lakala"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flavor_ruyi_huntun &#123;</span><br><span class="line">        applicationId <span class="string">'com.ipensee.newlikechainsruyiorder'</span></span><br><span class="line">        manifestPlaceholders = [shopkeeper_app_name: <span class="string">"新如意馄饨"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    flavor_ruyi_caifan &#123;</span><br><span class="line">        applicationId <span class="string">"$flavor_ruyi_huntun.applicationId"</span> + <span class="string">'.caifan'</span></span><br><span class="line">        manifestPlaceholders = [shopkeeper_app_name: <span class="string">"新如意菜饭"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个 productFlavor 定义了一个应用的自定义构建版本，一个单一的项目可以同时定义多个不同的 flavor 来改变应用的输出。 productFlavor 这个概念是为了解决不同的版本之间的差异非常小的情况，通常用于区分同一个应用的不同渠道/客户等，可包含少量业务功能差别。</p><p>注意： productFlavors 的自定义名字不能和后面要讲到的 buildType 中的名字相同，不然 Gradle 编译会不通过。在这里我们使用了“flavors_”前缀以便区分。</p><p>Line 5 <code>versionName &quot;$defaultConfig.versionName&quot; + &quot;.lakala&quot;</code> 的含义是，构建此定制产品的 apk 时，在 defaultConfig 中定义的版本名基础上，增加 “.lakala” 后缀。</p><p>Line 9 <code>applicationId &#39;com.ipensee.newlikechainsruyiorder&#39;</code> 的含义是，构建此定制产品的 apk 时，替换 defaultConfig 中定义的应用程序标识为 <code>com.ipensee.newlikechainsruyiorder</code> 。</p><p>Line 13 <code>applicationId &quot;$flavor_ruyi_huntun.applicationId&quot; + &#39;.caifan&#39;</code> 的含义是，构建此定制产品的 apk 时，在 flavor_ruyi_huntun 中定义的应用程序标识基础上，增加 “.caifan” 后缀，即使用 <code>com.ipensee.newlikechainsruyiorder.caifan</code> 作为应用程序标识。</p><p>Line 10、14 manifestPlaceholders 中所设置的变量可以直接使用在 AndroidManifest.xml 中，使用方式为：<code>${place_holder_name}</code>，例如：<code>android:label=&quot;${shopkeeper_app_name}${shopkeeper_app_suffix}&quot;</code>。</p><p>在Java代码中可以使用 <code>BuildConfig.FLAVOR</code> 来获取当前的 productFlavors ，以便根据不同的 productFlavors 使得程序呈现出不同的行为。</p><h2 id="buildTypes（构建类型）"><a href="#buildTypes（构建类型）" class="headerlink" title="buildTypes（构建类型）"></a>buildTypes（构建类型）</h2><p>完成的 build.gradle 文件中 buildTypes 代码段大致如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    debug &#123;</span><br><span class="line">        versionNameSuffix <span class="string">'.debug'</span></span><br><span class="line">        manifestPlaceholders = [shopkeeper_app_suffix: <span class="string">"Debug"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    release &#123;</span><br><span class="line">        signingConfig signingConfigs.ilike</span><br><span class="line">        minifyEnabled <span class="keyword">false</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        manifestPlaceholders = [shopkeeper_app_suffix: <span class="string">""</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    dev.initWith(buildTypes.release)</span><br><span class="line">    dev &#123;</span><br><span class="line">        versionNameSuffix <span class="string">'.dev'</span></span><br><span class="line">        manifestPlaceholders = [shopkeeper_app_suffix: <span class="string">"Dev"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认情况下，Android Plugin 会自动给项目设置同时构建应用程序的 debug 和 release 版本，我们根据实际应用需求又定制了 dev 版本和其他版本。一般来说，对于开发流程中不同阶段（如开发阶段、测试阶段、维护阶段等）的不同要求的定制可以使用 buildType 来实现，因此，相同 productFlavor 的不同 BuildType 构建版本之间通常没有业务功能的差别。</p><p>Line 3 <code>versionNameSuffix &#39;.debug&#39;</code> 的含义是，构建此版本 apk 时，在 productFlavor 指定的版本名基础上，增加 “.debug” 后缀。</p><p>Line 4、10、15 buildType 中 manifestPlaceholders 的用法同 productFlavor 中 manifestPlaceholders 的用法。</p><p>Line 7 <code>signingConfig signingConfigs.ilike</code> 的含义是构建此版本时使用签名配置 ilike 为 apk 签名。关于签名配置的更多内容后面再进行专门的说明。</p><p>Line 8、9 是关于代码混淆的设置，<code>minifyEnabled false</code> 代表不开启代码混淆特性。（注意，在低版本的 gradle 中此设置项名为 runProguard 。）</p><p>Line 12 <code>dev.initWith(buildTypes.release)</code> 的含义是构建类型 dev 是构建类型 release 的一个副本，即构建类型 dev 是在构建类型 release 的基础上又设置了一些构建参数（这里是设置了版本名后缀和应用名称后缀）得到的。</p><p>在Java代码中可以使用 <code>BuildConfig.BUILD_TYPE</code> 来获取当前的 buildType ，以便根据不同的 buildType 使得程序呈现出不同的行为。</p><h2 id="Product-Flavor-Build-Type-Build-Variant（定制产品-构建类型-构建变种版本）"><a href="#Product-Flavor-Build-Type-Build-Variant（定制产品-构建类型-构建变种版本）" class="headerlink" title="Product Flavor + Build Type = Build Variant（定制产品+构建类型=构建变种版本）"></a>Product Flavor + Build Type = Build Variant（定制产品+构建类型=构建变种版本）</h2><p>如前所述，每一个 buildType 都会生成一个新的 apk，每一个<br>productFlavor 同样也会生成一个新的 apk —— 即项目的输出将会拼接所有可能的 productFlavor（如果有Flavor定义存在的话）和 buildType 的组合。这样的每一种组合（包含 productFlavor 和 buildType ）就是一个 Build Variant（构建变种版本）。</p><p>虽然因 Build Variant 的不同，项目最终生成了多个定制的版本，但是它们本质上都是同一个应用。</p><p>例如前述 productFlavor 和 buildType 定义将会生成 12 个 Build Variant ：</p><ul><li>flavor_default - debug</li><li>flavor_default - release</li><li>flavor_default - dev</li><li>flavor_lakala - debug</li><li>flavor_lakala - release</li><li>flavor_lakala - dev</li><li>flavor_ruyi_huntun - debug</li><li>flavor_ruyi_huntun - release</li><li>flavor_ruyi_huntun - dev</li><li>flavor_ruyi_caifan - debug</li><li>flavor_ruyi_caifan - release</li><li>flavor_ruyi_caifan - dev</li></ul><p>代码中可以通过甄别不同的 productFlavor 和 buildType 实现程序的不同行为。若为项目开启了 JDK 7 的支持，更可以在 switch 中使用字符串条件来进行甄别，代码更加清晰，维护更加方便。</p><p>使用 JDK 7 需要修改构建文件， buildTools 要使用 19 以上版本，还要增加 compileOptions 配置：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_7</span><br><span class="line">        <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_7</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置好后除了可以在 switch 语句中使用字符串，还可以使用 diamond operator ， multi-catch 等 JDK 7 的新特性。</p><h2 id="multi-applicationId-与-AndroidAnnotations"><a href="#multi-applicationId-与-AndroidAnnotations" class="headerlink" title="multi-applicationId 与 AndroidAnnotations"></a>multi-applicationId 与 AndroidAnnotations</h2><p>为使得 AndroidAnnotations 框架能够兼容不同的 applicationId 设置， apt.arguments.resourcePackageName 参数一定要设置，例如：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        androidManifestFile variant.outputs[<span class="number">0</span>]?.processResources?.manifestFile</span><br><span class="line">        <span class="comment">// if you have multiple outputs (when using splits), you may want to have other index than 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// you should set your package name here if you are using different application IDs</span></span><br><span class="line">        resourcePackageName <span class="string">"$android.defaultConfig.applicationId"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="multi-applicationId-与-Robolectric"><a href="#multi-applicationId-与-Robolectric" class="headerlink" title="multi-applicationId 与 Robolectric"></a>multi-applicationId 与 Robolectric</h2><p>为使得 Robolectric 测试框架能在测试运行时找到正确的包名、manifest文件和资源文件夹， @Config 中的 packageName 、 manifest 和 resourceDir 参数一定要设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(RobolectricGradleTestRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Config</span>(<span class="title">sdk</span> </span>= <span class="number">21</span>, packageName = <span class="string">"cn.happylike.shopkeeper"</span>,</span><br><span class="line">        manifest = <span class="string">"./build/intermediates/manifests/full/"</span></span><br><span class="line">                + BuildConfig.FLAVOR + <span class="string">"/"</span> + BuildConfig.BUILD_TYPE + <span class="string">"/AndroidManifest.xml"</span>,</span><br><span class="line">        resourceDir = <span class="string">"./build/intermediates/res/merged/"</span></span><br><span class="line">                + BuildConfig.FLAVOR + <span class="string">"/"</span> + BuildConfig.BUILD_TYPE + <span class="string">"/"</span>,</span><br><span class="line">        constants = BuildConfig<span class="class">.<span class="keyword">class</span>, <span class="title">application</span> </span>= MainApplication_<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainActivityTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Robolectric 目前仅支持到 sdk 21 ，因此必须设置 <code>sdk = 21</code> ；</li><li>若不设置 packageName 参数， Robolectric 会默认包名与 applicationId 相同，会出现找不到类的错误；</li><li>若不设置 manifest 参数， Robolectric 会默认读取 sourceSet main 下的 AndroidManifest.xml 文件，其中若出现了占位符，则会报错；另外若是有根据 applicationId 或版本名不同有不同行为的代码，则会因为使用了 sourceSet main 中的默认设置而失效；</li><li>resourceDir 参数不设置可能出现找错资源文件的情况，程序若有依赖资源文件而不同的行为，可能会因 resourceDir 参数不设置而出现异常；</li></ul><h2 id="自定义签名文件路径"><a href="#自定义签名文件路径" class="headerlink" title="自定义签名文件路径"></a>自定义签名文件路径</h2><p>团队合作中各个开发者的开发设备不同，签名文件存放路径很可能不一样，尤其是使用不同操作系统的开发者，签名文件的路径可以说是肯定不一样。若是简单的在 build.gradle 文件中直接配置签名文件路径，每个开发者拉取代码后都要修改 build.gradle 文件，若是不小心提交覆盖了，别人再同步代码就又要合并代码解决冲突了，恶性循环。</p><p>最容易想到的解决方案可能是将签名文件放入项目中，这样就可以使用相对路径来指定签名文件位置，大家的 build.gradle 文件就一样了。<br>但这样一来，若是签名文件也纳入版本管理内，则签名文件将被提交到远程仓库，远程仓库中既有签名文件又有签名文件的密码（已经写在 build.gradle 文件里了），泄密可能大大增加；即使签名文件不纳入版本管理，也存在开发人员使用整个项目打包的形式交流代码时无意间泄露签名文件的可能。</p><p>最终我使用了参考文档[6]中的一个方法的变种，在 gradle.properties 文件中定义相关参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RELEASE_STORE_FILE=&#123;path to your keystore&#125;</span><br><span class="line">RELEASE_STORE_PASSWORD=******</span><br><span class="line">RELEASE_KEY_ALIAS=****</span><br><span class="line">RELEASE_KEY_PASSWORD=******</span><br></pre></td></tr></table></figure></p><p>上述参数在 build.gradle 中的应用如下代码所示：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    ilike &#123;</span><br><span class="line">        storeFile <span class="keyword">file</span>(RELEASE_STORE_FILE)</span><br><span class="line">        storePassword RELEASE_STORE_PASSWORD</span><br><span class="line">        keyAlias <span class="string">'like(来客)'</span> <span class="comment">//因keyAlias中包含中文故不能使用properties文件中的值，所以在这里写死</span></span><br><span class="line">        keyPassword RELEASE_KEY_PASSWORD</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>gradle.properties 文件应添加到版本管理的忽略文件列表中以尽可能保密。</strong></p><p>注意： .properties 文件中写中文易出现乱码问题，因此 keystore 的路径中不建议使用中文文件夹。</p><p><strong>特别强调</strong>： 向 .gitignore 中添加条目时需要注意的一点是——若新添加的条目所覆盖的文件已经存在于版本管理系统中了，需要从版本管理系统中删除（即将这个文件删除并提交）后，忽略才有效——因此建议对新添加的忽略条目在做好备份的情况下进行删除并提交再粘贴回来以实现真正的忽略跟踪。</p><h2 id="原理简析"><a href="#原理简析" class="headerlink" title="原理简析"></a>原理简析</h2><p>以上所有在 build.gradle 文件中做的各种配置，在你执行 <code>./gradlew build</code> 命令时，会逐个 Build Variant 地应用那些配置，生成完整版的代码、资源、manifest文件等等（参见参考文档[2]中的解析），而这些生成的文件都在在 app module下的 /build 文件夹内，重点可以看一下 /build/intermediates这个文件夹，把它下面的子文件夹都展开看看内容，相信你会有更深刻的理解，也更有能力解决配置错误导致的各种奇怪的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要参考文档有：&lt;/p&gt;
&lt;p&gt;[1]. &lt;a href=&quot;http://spencer-dev.com/blog/2015/android-xiang-mu-li-yong-android-studio-he-gradle-da-bao-duo-ban-ben-apk.html/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 项目利用 Android Studio 和 Gradle 打包多版本APK&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]. &lt;a href=&quot;http://blog.robustastudio.com/mobile-development/android/building-multiple-editions-of-android-app-gradle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Building Multiple Editions of an Android App with Gradle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]. &lt;a href=&quot;https://www.gitbook.com/book/avatarqing/gradlepluginuserguidechineseverision/details&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gradle Plugin User Guide 中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4]. &lt;a href=&quot;https://sites.google.com/a/android.com/tools/tech-docs/new-build-system/user-guide/manifest-merger&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Manifest Merger&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5]. &lt;a href=&quot;https://stackoverflow.com/questions/17976050/get-product-flavor-or-build-variant-in-an-android-app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Get product flavor or build variant in an android app&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6]. &lt;a href=&quot;https://stackoverflow.com/questions/18328730/how-to-create-a-release-signed-apk-file-using-gradle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to create a release signed apk file using Gradle?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我主要是从公司项目需求出发，依照参考文档[1]的思路学习配置Gradle来实现多版本、多ApplicationID的Apk打包，在学习过程中通过参考其他文档实现了与项目原本就采用的AndroidAnnotations框架和Robolectric测试框架的兼容，最后完成品可见此链接 &lt;a href=&quot;https://ipensee.3322.org:8388/developers/LikeShopkeeper/blob/95ce2c2744d8dfb3442aaae80f62213264ad4286/shopkeeper/build.gradle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;build.gradle&lt;/a&gt; （后面具体介绍时会有针对性地放出相关代码），实现了用gradle命令自动打包apk时具备以下效果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以根据渠道不同在版本名中增加相应后缀， 可以根据特殊客户要求打包不同 ApplicationID 的 apk 包，并可分别使用不同的资源文件（如不同的应用图标等）——主要使用 productFlavors 特性；&lt;/li&gt;
&lt;li&gt;可以为开发人员、测试人员、IT人员和正式用户打包不同的 apk 包，以便在程序行为上针对不同使用需求做少量定制（如是否可以更改远程服务器地址等）——主要使用 buildType 特性；&lt;/li&gt;
&lt;li&gt;打包不同 ApplicationID 的 apk 包时可以与 AndroidAnnotations 框架兼容不出错—— apt arguments 中设定 resourcePackageName 参数；&lt;/li&gt;
&lt;li&gt;测试不同 ApplicationID 的 apk 包时可以与 Robolectric 测试框架兼容不出异常——设置 TestCase 的 @Config 中各参数；&lt;/li&gt;
&lt;li&gt;打包时可根据需求自动签名，且签名文件不需要放在项目文件夹下，可以实现不同开发设备配置不同的签名文件路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面将针对上述各条效果分别说明实现方法，在阅读以下内容时请确保您已至少阅读上述参考文档[1]，并建议最好阅读完上述参考文档[2]、[3]。&lt;/p&gt;
    
    </summary>
    
      <category term="程序媛" scheme="https://chobitly.github.io/categories/%E7%A8%8B%E5%BA%8F%E5%AA%9B/"/>
    
    
      <category term="AndroidAnnotations" scheme="https://chobitly.github.io/tags/AndroidAnnotations/"/>
    
      <category term="Android Studio" scheme="https://chobitly.github.io/tags/Android-Studio/"/>
    
      <category term="打包Apk" scheme="https://chobitly.github.io/tags/%E6%89%93%E5%8C%85Apk/"/>
    
      <category term="Gradle" scheme="https://chobitly.github.io/tags/Gradle/"/>
    
      <category term="Robolectric" scheme="https://chobitly.github.io/tags/Robolectric/"/>
    
  </entry>
  
  <entry>
    <title>Android入门</title>
    <link href="https://chobitly.github.io/2015/10/20/Android-Training-Course/"/>
    <id>https://chobitly.github.io/2015/10/20/Android-Training-Course/</id>
    <published>2015-10-20T13:24:52.000Z</published>
    <updated>2020-07-17T08:53:52.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="References"><a href="#References" class="headerlink" title="References"></a><em>References</em></h1><ul><li><strong>Android Developers: <a href="https://developer.android.com" target="_blank" rel="noopener">https://developer.android.com</a></strong> Google的Android开发者官网。</li><li><strong>AndroidDevTools: <a href="http://www.androiddevtools.cn" target="_blank" rel="noopener">http://www.androiddevtools.cn</a></strong> 很好的资源站，整理了不少中英文Android开发文档，更搬运了许多资源到墙内，方便众开发人员。</li><li><strong>Google Android官方培训课程中文版: <a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="noopener">http://hukai.me/android-training-course-in-chinese/index.html</a></strong></li></ul><a id="more"></a><h1 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h1><ol><li>下载安装<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="noopener">Android Studio</a>.</li><li>使用<a href="http://developer.android.com/tools/help/sdk-manager.html" target="_blank" rel="noopener">SDK Manager</a>下载最新的SDK tools和platforms。</li></ol><h1 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h1><p>Follow the wizard.</p><h1 id="3-Activity"><a href="#3-Activity" class="headerlink" title="3. Activity"></a>3. Activity</h1><p><img src="../../../../images/basic-lifecycle.png" alt="Activity的生命周期"></p><h1 id="AND-MORE…"><a href="#AND-MORE…" class="headerlink" title="AND MORE…"></a><em>AND MORE…</em></h1><ul><li><strong>Android Annotations: <a href="http://androidannotations.org" target="_blank" rel="noopener">http://androidannotations.org</a></strong> An Open Source framework that speeds up Android development.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;&lt;em&gt;References&lt;/em&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Android Developers: &lt;a href=&quot;https://developer.android.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.android.com&lt;/a&gt;&lt;/strong&gt; Google的Android开发者官网。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AndroidDevTools: &lt;a href=&quot;http://www.androiddevtools.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.androiddevtools.cn&lt;/a&gt;&lt;/strong&gt; 很好的资源站，整理了不少中英文Android开发文档，更搬运了许多资源到墙内，方便众开发人员。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Google Android官方培训课程中文版: &lt;a href=&quot;http://hukai.me/android-training-course-in-chinese/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hukai.me/android-training-course-in-chinese/index.html&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="程序媛" scheme="https://chobitly.github.io/categories/%E7%A8%8B%E5%BA%8F%E5%AA%9B/"/>
    
    
      <category term="Android" scheme="https://chobitly.github.io/tags/Android/"/>
    
      <category term="Training" scheme="https://chobitly.github.io/tags/Training/"/>
    
      <category term="Android Training" scheme="https://chobitly.github.io/tags/Android-Training/"/>
    
  </entry>
  
  <entry>
    <title>Somethings about AA&#39;s BackgroundExecutor</title>
    <link href="https://chobitly.github.io/2015/05/07/AA-BackgroundExecutor/"/>
    <id>https://chobitly.github.io/2015/05/07/AA-BackgroundExecutor/</id>
    <published>2015-05-07T14:51:51.000Z</published>
    <updated>2020-07-17T08:53:52.523Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下公司工作里使用AndroidAnnotations出现的一个问题的解决过程。<br><a id="more"></a><br>由AA的实现机制可知，一个被标记为<code>@Background</code>的方法，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EActivity</span>(R.layout.activity_main)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Background</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...<span class="comment">// do anything you like</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AA实际生成的代码是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity_</span> <span class="keyword">extends</span> <span class="title">SampleActivity</span> <span class="keyword">implements</span> <span class="title">HasViews</span>, <span class="title">OnViewChangedListener</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BackgroundExecutor.execute(<span class="keyword">new</span> BackgroundExecutor.Task(<span class="string">""</span>, <span class="number">0</span>, <span class="string">""</span>) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SampleActivity_.<span class="keyword">super</span>.method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">Thread.getDefaultUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，我们在方法<code>method()</code>中写的代码，即使是进了方法后的第一行代码，事实上也必须在<code>BackgroundExecutor</code>从线程池中获取到可用的后台线程后，才会被执行，如果线程池当前已满，就必须等到现有的线程有彻底执行完毕的，才会将执行<code>method()</code>中的代码排上日程，于是在低配手机上，频繁测试后很容易出现按钮不响应的现象——线程池满啦！<br>这显然是我们不愿意见到的。<br>于是我查找了项目中使用<code>@Background</code>的所有地方，将进入<code>@Background</code>的方法后才做的出现loading框和禁用相关联控件的代码都提出到调用这个方法的语句之前。<br>之前之所以放那里是因为我在库项目里封装了<code>showProgress()</code>系列方法，能够方便地用一行代码实现将出现loading框和禁用相关联控件的操作post回主线程执行，放在此处可以避免多次调用<code>@Background</code>方法漏掉这个语句，但现在看来这个小心思显然有点儿蠢。<br>顺便这时候我还去更新了库项目，对<code>showProgress()</code>系列方法增加了判断当前线程是不是UI线程的代码，以期达到更好的运行效率，在已经是身处UI线程的情况下，省掉了new一个<code>Runnable</code>对象所带来的资源分配开销。</p><p>顺便也是基于同样的理由，建议后续使用AA的项目中，在用到<code>@UiThread</code>时，如果此方法既可能被Background线程调用又可能被UI线程调用，建议使用<code>(propagation = Propagation.REUSE)</code>标示来节省资源。但若你很清楚此方法仅仅会在Background线程中调用的话，建议还是不要加标示了，毕竟判断当前线程是否是UI线程的代码执行时候也是要消耗时间的。<br>并且，如果一个方法仅仅会在UI线程中被执行，调用它的方法也都很明确是运行在UI线程中的方法（包括已经被标示为<code>@UiThread</code>的方法和各种控件的点击事件、触摸事件等），则不建议将这个方法再标示为<code>@UiThread</code>的方法，即，不要滥用AA标记！</p><p>但是事情到这里还没有结束，虽然我很想到此为止了，但是这样实际上是治标不治本的，只是防止了多次点击，并没有解决操作缓慢的问题。<br>于是再次求助谷歌——“万能的谷哥哟，为什么BackgroundExecutor会执行缓慢呢？”<br>在数不清的搜索结果中，这样一个条目引起了我的注意：<a href="https://github.com/excilys/androidannotations/issues/625" target="_blank" rel="noopener">New BackgroundExecutor is failing in my app</a>。这是一位名为RomainPiel的朋友在AA的开源项目中提交的一条issue，点进去详细看一下，几乎与我们碰到的现象一模一样！<br>“别高兴的太早，继续看下去，问题解决了吗？”带着疑问滚动着页面，终于发现了这么一条回复：</p><blockquote><p>rom1v commented on 11 Jun 2013</p><p>@RomainPiel The executor has a fixed number of threads.<br>If you submit more tasks than this threshold, then your tasks will be blocked until previous ones have completed execution.</p><p>Before pull request #569, Executor implementation was Executors.newCachedThreadPool(), so your threads were not blocked above a threshold.</p><p>But you should not rely on this unspecified behaviour: if you need to start a lot of long-running threads, then you must set your own Executor to ensure the behaviour:</p><p><code>BackgroundExecutor.setExecutor(Executors.newCachedThreadPool());</code></p></blockquote><p>顺着这条回复提供的线索，我找到pull request #569当时对<code>BackgroundExecutor</code>所做的更改，在这次提交中，<code>BackgroundExecutor</code>的<code>DEFAULT_EXECUTOR</code>被改成了<br><code>Executors.newScheduledThreadPool(2 * Runtime.getRuntime().availableProcessors());</code>。<br>个人揣测这么做的原因是想要节约系统资源，避免滥用多线程拖慢系统的情况发生。<br>在当前四核八核机当道的Android机市场上，这样的代码也许问题并不大，线程池中允许同时运行十几个线程对大多数的应用来收都足够了，在我们的应用里，每个界面中的<code>@Background</code>其实鲜有并行执行的。但是在早期的单核Android手机上，这样的线程池规模显然就捉襟见肘了。<br>找到了问题所在，下一步当然就是fix it了！<br>但是我必须坦承，现在的解决方案并不算好，甚至可以说是很简陋，我所做的事情就是在应用的<code>MainApplication</code>的<code>onCreate()</code>方法中增加了这么一句：<br><code>BackgroundExecutor.setExecutor(Executors.newCachedThreadPool());</code><br>相当简陋，用回<code>Executors.newCachedThreadPool()</code>也就意味着我们放弃了AA节约系统资源的这次努力，又开始铺张浪费了XD，不是好习惯XD。<br>所以，后续在这方面可能还需要再进行一些研究，现在考虑可能有这么几个方向：</p><ul><li>用回<code>Executors.newScheduledThreadPool(n)</code>，但是要如何确定一个合适的<code>n</code>值？</li><li>是否还有其他<code>Executor</code>能够实现线程池的动态扩展，按需扩展？</li><li>……</li><li>AA现在提供了为<code>@Background</code>方法指定ID来实现cancel，在合适的时候取消后台线程的执行，从代码编写上更严密地避免无用后台线程占用资源。</li><li>是否自己实现一个新的<code>Executor</code>来满足以上所有需求？</li></ul><p>以上，就是这两天解决问题的所思所想。对公司其他使用了AA的项目，建议先采用当前的解决方案，在应用的<code>MainApplication</code>的<code>onCreate()</code>方法中增加<code>BackgroundExecutor.setExecutor(Executors.newCachedThreadPool());</code>来应对低配手机上的不响应问题。<br>求大神们提出更好的解决资源浪费问题的解决方案～～</p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下公司工作里使用AndroidAnnotations出现的一个问题的解决过程。&lt;br&gt;
    
    </summary>
    
      <category term="程序媛" scheme="https://chobitly.github.io/categories/%E7%A8%8B%E5%BA%8F%E5%AA%9B/"/>
    
    
      <category term="Android" scheme="https://chobitly.github.io/tags/Android/"/>
    
      <category term="AndroidAnnotations" scheme="https://chobitly.github.io/tags/AndroidAnnotations/"/>
    
  </entry>
  
  <entry>
    <title>记一次Android OOM问题的解决</title>
    <link href="https://chobitly.github.io/2013/07/01/Android-OOM/"/>
    <id>https://chobitly.github.io/2013/07/01/Android-OOM/</id>
    <published>2013-07-01T10:39:19.000Z</published>
    <updated>2020-07-17T08:53:52.523Z</updated>
    
    <content type="html"><![CDATA[<p>一个困扰了我一个多礼拜的OOM bug今天终于给解决掉了，前辈攻城狮说OOM这种东西总是由不起眼的东西引起的，此言不虚啊！<br>最初客户回报上来的症状是程序莫名卡死、黑屏，无法操作乃至需要重启设备才能恢复正常（ <strong>这里我学到了一个道理：客户都是没什么耐心的。</strong> 其实多等几秒系统杀掉程序出现FC对话框就不需要重启设备了的说）。<br><a id="more"></a></p><p>起初我希望能重现bug然后根据Logcat的报告定位错误，但是尽管我用尽办法各种虐待我的GN，总是无法重现问题。这样没头没脑地耗了两天（期间还在做别的代码，也没浪费时间），于是在一个闷热的下午，程序媛我背上背包出了现场。（为了出这个现场还差点把自己笔记本的网卡们搞死，真是辛苦它们了。）<br>总觉得我有bug退散体质的说，在客户店里从下午坐到晚上一直风平浪静，倒是刚到那里的时候随便点了两下就在Logcat里捕捉到了一次OOM。<br>晚上九点收集了一下服务员们的使用体验并征求老板同意带回了一台设备准备进一步查找问题。</p><p>第二天一早刚开始研究就又出现OOM了，这时候我反省了一下盲目寻找容易引起OOM的代码模式加以修改的做法，开始用内存分析工具武装我的Eclipse，装了MAT插件。<br>接下来各种测试各种看内存分析报告，首先是了解了GN不能重现黑屏问题的原因——丫为一个App分配了四五十兆的内存的情况下还是能蹒跚而行，而客户用的采用三星定制Rom的设备可没有如此大的胸怀。不过至少GN也是会有潜在OOM的可能的，我可以把客户的设备还回去了。</p><p>能够定位到无法GC的Activity有一大半要归功于运气，我就是在无数的类列表里看到了它！其实它本身占用的内存并不大，根本排不到前面，我几乎是在绝望的时候漫无目的地随手展开着内存报告的列表的时候注意到了它出现了多个实例！虽然一个Activity占用的内存不大，但是一个Activity里会有很多控件，这样一套下来的内存占用也很可观了！<br>自此我开始专注于这个Activity内部寻找引起OOM的代码，这里离最终解决其实还是有很大差距的，但是内容我就不详述了，不外乎是各种二分法缩小问题代码范围。<br><strong>最终找到的原因是我在一个Dialog的布局xml里使用了<code>&lt;requestForcs  /&gt;</code>这一句，去掉以后各种正常。</strong></p><p>兴奋过后回顾在今天下午定位到这一句之前走过的一些弯路，突然发现有一点并不能很好的得到解释：<br>我曾经试过注释掉那个Acitivity里几乎所有的代码（为什么说是几乎所有呢？后面解释），然后更换Activity的指向的界面xml，同样内容的两个xml文件（都不是最初引起不释放的那个布局文件）却一个能够释放一个不能释放；这个诡异的现象在我去掉这个Activity主题中的android:windowIsTranslucent属性后消失了，所以我曾经一度认为是这个属性引起的bug，不过最后找到问题所在以后做的回归测试给它平了反。<br>虽然现在问题得到了解决，但是这个查找问题过程中碰到的诡异现象实在是有些匪夷所思。没错，我前面所说的注释掉的“几乎所有”的代码中，并不包括引起问题的代码，那一份错误的xml在我为Acitivity更换各种xml的过程中始终都是会被加载的——我在一个自定义对话框的构造函数中inflate了它，而new那个对话框的语句在我更换Activity的布局文件过程中始终在运行着。<br><em>Maybe，我只是眼花了。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个困扰了我一个多礼拜的OOM bug今天终于给解决掉了，前辈攻城狮说OOM这种东西总是由不起眼的东西引起的，此言不虚啊！&lt;br&gt;最初客户回报上来的症状是程序莫名卡死、黑屏，无法操作乃至需要重启设备才能恢复正常（ &lt;strong&gt;这里我学到了一个道理：客户都是没什么耐心的。&lt;/strong&gt; 其实多等几秒系统杀掉程序出现FC对话框就不需要重启设备了的说）。&lt;br&gt;
    
    </summary>
    
      <category term="程序媛" scheme="https://chobitly.github.io/categories/%E7%A8%8B%E5%BA%8F%E5%AA%9B/"/>
    
    
      <category term="Android" scheme="https://chobitly.github.io/tags/Android/"/>
    
      <category term="OOM" scheme="https://chobitly.github.io/tags/OOM/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://chobitly.github.io/1986/10/31/Hello-World/"/>
    <id>https://chobitly.github.io/1986/10/31/Hello-World/</id>
    <published>1986-10-31T10:18:18.000Z</published>
    <updated>2020-07-17T08:53:52.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World!&quot;&gt;&lt;/a&gt;Hello World!&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Hello World" scheme="https://chobitly.github.io/tags/Hello-World/"/>
    
  </entry>
  
</feed>
